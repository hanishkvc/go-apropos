#############
Go Apropos
#############
HanishKVC, 2022

Overview
#########

go doc requires one to already know the standard package to look for,
to get info about the same. However if one doesnt know which package
may contain what they want, they will have to grep the src directory
or do a web search.

This provides something like the apropos command wrt man pages, but
here it searchs for matching symbols/comments/packagenames from among
the packages in the go source directory.

NOTE: Symbol refers to const or var or type or func name.

As I wanted to look at Go lang a bit, so found this need and thus this.
However I havent really looked at Go or read through Go documentation,
so this code could be as far away from the conventions and concepts in
Go land. This is based on some quick random scanning of docs and go src
followed by compilation errors and potentially flawed logical guess work.
At same time, it should do the job and be useful when exploring Go lang.

Usage
######

Normal Use
============

By default it uses 1st directory under /usr/share or /usr/local/share
or /usr/lib which matchs the pattern "go-*" or "golang*" as the go source
directory wrt packages to search for. If required one can explicitly set
the go source directory by using the cmdline arg

	goapropos --basepath <base_path> search_token

NOTE: Logic doesnt follow symbolic links under the go source directory

One can specify the token to use to match / search for symbols in
packages by using either the cmdline arg --find or by just specifing
it in the cmdline ie.

	goapropos --find search_token

	OR

	goapropos search_token

By default it tries to find matching exported symbols only from available
packages. However If one wants the logic to use both internal and exported
symbols of the packages when trying to find a match, one needs to specify
the cmdline argument --allsymbols.

	goapropos --allsymbols search_token

By default it tries to search through all the packages in the identified
go source directory. However if required one can filter the packages that
will be searched by using --findpkg argument. The  token given through
findpkg argument will be used to filter the package names for a match.

	goapropos --findpkg packagename_token search_token

If one wants to get a list of package names, which match a given token, one
can run goapropos with only the findpkg argument and no find argument.

	goapropos --findpkg packagename_token

To get all the exported symbols of all the packages, use

	goapropos --find ""

If one wants to find symbols based on their comments if any, then they can
use --findcmt to specify a match token wrt comment. Any symbols which contain
comments that match the specified token will be shown to the user.

NOTE: If the comment being searched for is found at a generic file level,
rather than wrt a specific symbol within it, then the package name of the
file is shown.

	goapropos --findcmt a_search_token
	ex: goapropos --findcmt "device"

The tokens specified are used to match package name or the symbols or their
comments as the case maybe by using a case insensitive search, by default.
If one wants to use case sensitive matching, pass --casesensitive.

By default if the package name or symbol or comment contains the given token,
as a substring within itself, it will be treated as a match. This is called
the contains matchmode. However if required one can use regular expression
based matching by specifying --matchmode regexp. If the specified mode is
unknown, then contains matchmode will be used as the fallback.

	goapropos matchtoken_substring
	ex: goapropos fmt

	goapropos --matchmode contains matchtoken_substring
	ex: goapropos --matchmode contains fmt

	goapropos --matchmode regexp matchtoken_regexp
	ex: goapropos --matchmode regexp "fm.*t"
	ex: goapropos --matchmode regexp "fm+t"

NOTE: by default the match tokens as well as the pkg names/symbols/comments
will be converted to upper case if casesensitive search is disabled (which
is the default). Any implications of this wrt regexp if any needs to be
kept in mind. Inturn enablign casesensitive searching will disable this
automatic upper case conversion and inturn will leave the match token,
as well as the pkg names and symbols and comments as it is.

One can skip files matching certain predefined substrings in their name or
path by using --skipfiles. One can specify multiple matching tokens to filter
out source files from different-paths/... by using skipfiles multiple times.

	--skipfiles "substring" (skip files containing substring in their path)

	goapropos --skipfiles "/src/cmd/" --skipfiles "/src/internal/" findme


Remember to pass the named arguments/flags before any unnamed args to the
program.

Cache Use
===========

Instead of parsing the go source files each time the program is called, One
can ask it to create a cache of the requried data and inturn use the same.

Use the flag --createcache to create / update the cache of data wrt package
symbols, paths and comments.

	goapropos --createcache

Use the flag --usecache to use a previously created cache rather than freshly
parsing through the go source files.

	goapropos --usecache search_token

NOTE: One needs to first create the cache before trying to use it.


TODO
######

DONE: A optional simple regular expression based token matching option has
been added.

DONE: Allow searching through package / identifier comments, if possible. Have
added logic to extract comments at a basic level. TODO: Comments at the block
level wrt const or var containing multiple definitions needs to be accounted.

Maybe simplify by using parseDir on dirs and no need to look at the src files
individually seperately. However this may not skip test go source files in
them, parsing of which can be avoided by walking through files and calling
parseFile on them, like current flow. THink of this later.

DONE:Maybe add support to cache the package identifiers/paths/comments map.
This will inturn require a cmdline argument to force rebuilding of this cache,
when required.

Compile regexp match tokens, later.

Maybe later add support for searching multiple different comment tokens and
or symbol tokens. Currently one can search for either a single symbol or
single comment or one symbolORcomment match tokens together.

Build seperate maps wrt each go routine, and then merge them at the end.
This should allow the go routines to run without blocking when trying to
update map / db, unlike today, when they block as they need to synchronise
when trying to update a single map / db.. [DONE: But didnt gain much, if any,
performance, bcas rather availability of multiple go routines for working
with multiple files parallely, seems to be bypassing from this contention
becoming the hot path.]


Note
######

AST and Parsing
=================

From a initial quick glance at golang source found go/ast and its Inspect
function. Inturn to feed Inspect found parser.parseFile to parse go source
files.

However on using them found that no package ast node or comment related nodes
(comment/commentgroup) was getting found at any level, by looking at the call
back function of Inspect. Then there was also that mode argument to parseFile
which I had not yet looked at.

From another quick glance at source files in go/ast, go/doc and go/parser,
as also looking at go doc parser I can see a parser.parseDir, which seems to
return package nodes (as a given source directory could have multiple pkgs).
Also found bits about the Mode type and inturn ParseComments.

By using the go/ast and inturn the nodes that it extracts during inspecting
of the go source files, realised that ast.Ident node is triggered for both
own as well as others' (bcas the go source file refers to symbols from the
packages it uses) symbols which is found in a go source file. WHile GenDecl/
ValueSpec/TypeSpec/FuncDecl nodes are triggered only for own symbols, which
the go source file being inspected, defines.


Changelog
############

Rather major changes

20220614+
==========

Use go routines to see how things go. Here the walking of dir is made
parallel to the handling of the file. Logically this shouldnt and doesnt
change performance much, rightly so. Rather the overhead with go routines,
if any, makes the overall logic bit more slower compared to the NoGoRoutines
version.

Wrt each symbol store just the comments related string, thus simplifying
the flow. This should simplify the json loading and inturn seems to speed up
usecache based search by around 20-25%.

Add support for Multiple Go Routines wrt file handling, so that even when
there is a contention like trying to update the shared global db or a io
delay like reading a file, there is some other go routine to make use of
the available cpu/processing resources.

    This version is about 25% faster than the No Go routines version.

Use independent maps wrt each go routine, so that there is no need for any
contention to a shared global database when they are running. Then at the
end build a merged global database.

    The multiple go routines seems to be hiding any contention wrt shared
    global db, as had been hoped. This version didnt change performance much.
    This also indicates that there is enough io bandwidth to spare on the
    test machine and potentially in general on other machines also, to allow
    the parallel go routines to munch on additional files.

Make both raw source file parsing and cache based paths handle find++ queries
in equivalently similar ways.


20220612
==========

Cache and use the Maps/Database created wrt Pkg symbols, paths and comments.
User needs to pass named arguments to enable the creation as well as use of
cache.


20220610
==========

Avoid populating the apropos's pkg symbols database with symbols from other
pkgs used by a given go source file. IE avoid using ast.Ident node.

A bit more flexible find go source directory logic.

Link comment at the block level wrt consts or vars or types to the members
of the block, so that a search for any part of such a comment will list all
the members of that block.

If a comment level search matches any of the generic level comments in any
of the files belonging to that package, instead of to the comment specific
to a symbol, then the package name will be shown.


20220608
==========

A almost basic level of go apropos logic has been implemented.

